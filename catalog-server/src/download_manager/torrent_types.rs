//! Quentin Torrentino API types.
//!
//! Defines ticket structures, API responses, and WebSocket messages
//! for communication with the Quentin Torrentino service.

use serde::{Deserialize, Serialize};

// =============================================================================
// Ticket Request Types (sent to QT)
// =============================================================================

/// A music download ticket request sent to Quentin Torrentino.
#[derive(Debug, Clone, Serialize)]
pub struct MusicTicket {
    /// Unique ticket ID (generated by catalog-server)
    pub ticket_id: String,
    /// When the ticket was created
    pub created_at: String,
    /// Content type (always "music" for now)
    pub content_type: String,
    /// Search criteria for finding the torrent
    pub search: SearchInfo,
    /// Tracks to download
    pub tracks: Vec<TrackInfo>,
    /// Images to download (empty for audio-only scope)
    pub images: Vec<ImageInfo>,
    /// Audio format constraints
    pub constraints: AudioConstraints,
    /// Metadata to embed in downloaded files
    pub metadata_to_embed: MetadataEmbed,
}

/// Search criteria for finding a torrent.
#[derive(Debug, Clone, Serialize)]
pub struct SearchInfo {
    /// Artist name for search
    pub artist: String,
    /// Album name for search
    pub album: String,
    /// Release year (optional)
    pub year: Option<i32>,
    /// Record label (optional)
    pub label: Option<String>,
    /// Genres (optional)
    pub genres: Vec<String>,
}

/// Information about a track to download.
#[derive(Debug, Clone, Serialize)]
pub struct TrackInfo {
    /// Track ID (catalog track ID)
    pub id: String,
    /// Disc number
    pub disc_number: i32,
    /// Track number on disc
    pub track_number: i32,
    /// Track name
    pub name: String,
    /// Duration in seconds
    pub duration_secs: u32,
    /// Destination path for the downloaded file
    pub dest_path: String,
    /// Whether this track was explicitly requested
    pub requested: bool,
}

/// Information about an image to download.
#[derive(Debug, Clone, Serialize)]
pub struct ImageInfo {
    /// Image ID
    pub id: String,
    /// Image type (cover_front, artist_portrait, etc.)
    #[serde(rename = "type")]
    pub image_type: String,
    /// Destination path for the downloaded file
    pub dest_path: String,
}

/// Audio format constraints.
#[derive(Debug, Clone, Serialize)]
pub struct AudioConstraints {
    /// Desired format (ogg_vorbis, mp3, flac)
    pub format: String,
    /// Target bitrate in kbps
    pub bitrate_kbps: u32,
    /// Sample rate in Hz
    pub sample_rate_hz: u32,
    /// Whether to embed metadata tags
    pub embed_metadata: bool,
    /// Whether to embed cover art
    pub embed_cover: bool,
}

impl Default for AudioConstraints {
    fn default() -> Self {
        Self {
            format: "ogg_vorbis".to_string(),
            bitrate_kbps: 320,
            sample_rate_hz: 44100,
            embed_metadata: true,
            embed_cover: true,
        }
    }
}

/// Metadata to embed in downloaded audio files.
#[derive(Debug, Clone, Serialize)]
pub struct MetadataEmbed {
    pub artist: String,
    pub album: String,
    pub year: Option<i32>,
    pub genre: Option<String>,
}

// =============================================================================
// Ticket Response Types (received from QT)
// =============================================================================

/// Response when creating a ticket.
#[derive(Debug, Clone, Deserialize)]
pub struct TicketResponse {
    /// Ticket ID assigned by QT
    pub ticket_id: String,
    /// Initial state
    pub state: String,
}

/// Current state of a ticket.
#[derive(Debug, Clone, Deserialize)]
pub struct TicketState {
    /// Ticket ID
    pub ticket_id: String,
    /// Current state
    pub state: String,
    /// State-specific details
    pub state_details: Option<serde_json::Value>,
    /// State history
    pub history: Vec<StateHistoryEntry>,
}

/// Entry in ticket state history.
#[derive(Debug, Clone, Deserialize)]
pub struct StateHistoryEntry {
    /// State name
    pub state: String,
    /// When this state was entered
    pub entered_at: String,
}

/// QT statistics response.
#[derive(Debug, Clone, Deserialize)]
pub struct QTStats {
    pub pending: i64,
    pub downloading: i64,
    pub completed_today: i64,
}

// =============================================================================
// WebSocket Message Types
// =============================================================================

/// WebSocket message received from Quentin Torrentino.
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum TorrentEvent {
    /// Ticket changed state
    StateChange {
        ticket_id: String,
        old_state: String,
        new_state: String,
        details: Option<serde_json::Value>,
    },
    /// Download progress update
    Progress {
        ticket_id: String,
        state: String,
        progress_pct: f32,
        speed_bps: Option<u64>,
        eta_secs: Option<u64>,
    },
    /// Ticket needs manual approval (multiple torrent candidates)
    NeedsApproval {
        ticket_id: String,
        candidates: Vec<TorrentCandidate>,
    },
    /// Ticket completed successfully
    Completed {
        ticket_id: String,
        items_placed: u32,
    },
    /// Ticket failed
    Failed {
        ticket_id: String,
        error: String,
        retryable: bool,
    },
}

/// A torrent candidate for manual selection.
#[derive(Debug, Clone, Deserialize)]
pub struct TorrentCandidate {
    /// Candidate title/name
    pub title: String,
    /// Match score (0.0-1.0)
    pub score: f32,
    /// Number of seeders
    pub seeders: u32,
    /// Size in bytes
    pub size_bytes: Option<u64>,
}

// =============================================================================
// Ticket Status Enum (mirrors QT states)
// =============================================================================

/// Ticket status states from Quentin Torrentino.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TicketStatus {
    /// Initial state, waiting to be processed
    Pending,
    /// Searching for matching torrents
    Searching,
    /// Matching found torrents to tracks
    Matching,
    /// Waiting for admin approval (multiple candidates)
    NeedsApproval,
    /// Approved for download
    Approved,
    /// Downloading torrent
    Downloading,
    /// Converting audio format
    Converting,
    /// Placing files in destination
    Placing,
    /// Successfully completed
    Completed,
    /// Search found no results
    SearchFailed,
    /// Rejected by admin
    Rejected,
    /// Failed (may be retryable)
    Failed,
}

impl TicketStatus {
    /// Parse from string (QT API format).
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_uppercase().as_str() {
            "PENDING" => Some(Self::Pending),
            "SEARCHING" => Some(Self::Searching),
            "MATCHING" => Some(Self::Matching),
            "NEEDS_APPROVAL" => Some(Self::NeedsApproval),
            "APPROVED" | "AUTO_APPROVED" => Some(Self::Approved),
            "DOWNLOADING" => Some(Self::Downloading),
            "CONVERTING" => Some(Self::Converting),
            "PLACING" => Some(Self::Placing),
            "COMPLETED" => Some(Self::Completed),
            "SEARCH_FAILED" => Some(Self::SearchFailed),
            "REJECTED" => Some(Self::Rejected),
            "FAILED" => Some(Self::Failed),
            _ => None,
        }
    }

    /// Convert to database string.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Pending => "PENDING",
            Self::Searching => "SEARCHING",
            Self::Matching => "MATCHING",
            Self::NeedsApproval => "NEEDS_APPROVAL",
            Self::Approved => "APPROVED",
            Self::Downloading => "DOWNLOADING",
            Self::Converting => "CONVERTING",
            Self::Placing => "PLACING",
            Self::Completed => "COMPLETED",
            Self::SearchFailed => "SEARCH_FAILED",
            Self::Rejected => "REJECTED",
            Self::Failed => "FAILED",
        }
    }

    /// Returns true if this is a terminal state.
    pub fn is_terminal(&self) -> bool {
        matches!(
            self,
            Self::Completed | Self::SearchFailed | Self::Rejected | Self::Failed
        )
    }

    /// Returns true if this state indicates success.
    pub fn is_success(&self) -> bool {
        matches!(self, Self::Completed)
    }

    /// Returns true if this state indicates an error.
    pub fn is_error(&self) -> bool {
        matches!(self, Self::SearchFailed | Self::Rejected | Self::Failed)
    }
}

// =============================================================================
// Ticket Mapping (local DB)
// =============================================================================

/// Mapping between local queue item and QT ticket.
#[derive(Debug, Clone, Serialize)]
pub struct TicketMapping {
    /// Local queue item ID
    pub queue_item_id: String,
    /// QT ticket ID
    pub ticket_id: String,
    /// Current ticket state (from QT)
    pub ticket_state: TicketStatus,
    /// Album ID this ticket is for
    pub album_id: String,
    /// When the ticket was created
    pub created_at: i64,
    /// When the ticket state was last updated
    pub updated_at: i64,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ticket_status_from_str() {
        assert_eq!(TicketStatus::from_str("PENDING"), Some(TicketStatus::Pending));
        assert_eq!(TicketStatus::from_str("DOWNLOADING"), Some(TicketStatus::Downloading));
        assert_eq!(TicketStatus::from_str("AUTO_APPROVED"), Some(TicketStatus::Approved));
        assert_eq!(TicketStatus::from_str("invalid"), None);
    }

    #[test]
    fn test_ticket_status_terminal() {
        assert!(!TicketStatus::Pending.is_terminal());
        assert!(!TicketStatus::Downloading.is_terminal());
        assert!(TicketStatus::Completed.is_terminal());
        assert!(TicketStatus::Failed.is_terminal());
        assert!(TicketStatus::Rejected.is_terminal());
    }

    #[test]
    fn test_audio_constraints_default() {
        let constraints = AudioConstraints::default();
        assert_eq!(constraints.format, "ogg_vorbis");
        assert_eq!(constraints.bitrate_kbps, 320);
    }

    #[test]
    fn test_torrent_event_deserialize() {
        let json = r#"{"type": "completed", "ticket_id": "abc123", "items_placed": 12}"#;
        let event: TorrentEvent = serde_json::from_str(json).unwrap();
        match event {
            TorrentEvent::Completed { ticket_id, items_placed } => {
                assert_eq!(ticket_id, "abc123");
                assert_eq!(items_placed, 12);
            }
            _ => panic!("Expected Completed event"),
        }
    }

    #[test]
    fn test_torrent_event_failed_deserialize() {
        let json = r#"{"type": "failed", "ticket_id": "abc123", "error": "No torrents found", "retryable": true}"#;
        let event: TorrentEvent = serde_json::from_str(json).unwrap();
        match event {
            TorrentEvent::Failed { ticket_id, error, retryable } => {
                assert_eq!(ticket_id, "abc123");
                assert_eq!(error, "No torrents found");
                assert!(retryable);
            }
            _ => panic!("Expected Failed event"),
        }
    }
}
